<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>botball.core.helpers.enum API documentation</title>
<meta name="description" content="Python Enumerations" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>botball.core.helpers.enum</code></h1>
</header>
<section id="section-intro">
<p>Python Enumerations</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># ======================================== #
# Python 3.4 Enum polyfill - Do not modify #
# https://pypi.org/project/enum34          #
# ======================================== #

&#34;&#34;&#34;Python Enumerations&#34;&#34;&#34;

import sys as _sys

__all__ = [&#39;Enum&#39;, &#39;IntEnum&#39;, &#39;unique&#39;]

version = 1, 1, 6

pyver = float(&#39;%s.%s&#39; % _sys.version_info[:2])

try:
    any
except NameError:
    def any(iterable):
        for element in iterable:
            if element:
                return True
        return False

try:
    from collections import OrderedDict
except ImportError:
    OrderedDict = None

try:
    basestring
except NameError:
    # In Python 2 basestring is the ancestor of both str and unicode
    # in Python 3 it&#39;s just str, but was missing in 3.1
    basestring = str

try:
    unicode
except NameError:
    # In Python 3 unicode no longer exists (it&#39;s just str)
    unicode = str

class _RouteClassAttributeToGetattr(object):
    &#34;&#34;&#34;Route attribute access on a class to __getattr__.

    This is a descriptor, used to define attributes that act differently when
    accessed through an instance and through a class.  Instance access remains
    normal, but access to an attribute through a class will be routed to the
    class&#39;s __getattr__ method; this is done by raising AttributeError.

    &#34;&#34;&#34;
    def __init__(self, fget=None):
        self.fget = fget

    def __get__(self, instance, ownerclass=None):
        if instance is None:
            raise AttributeError()
        return self.fget(instance)

    def __set__(self, instance, value):
        raise AttributeError(&#34;can&#39;t set attribute&#34;)

    def __delete__(self, instance):
        raise AttributeError(&#34;can&#39;t delete attribute&#34;)


def _is_descriptor(obj):
    &#34;&#34;&#34;Returns True if obj is a descriptor, False otherwise.&#34;&#34;&#34;
    return (
            hasattr(obj, &#39;__get__&#39;) or
            hasattr(obj, &#39;__set__&#39;) or
            hasattr(obj, &#39;__delete__&#39;))


def _is_dunder(name):
    &#34;&#34;&#34;Returns True if a __dunder__ name, False otherwise.&#34;&#34;&#34;
    return (name[:2] == name[-2:] == &#39;__&#39; and
            name[2:3] != &#39;_&#39; and
            name[-3:-2] != &#39;_&#39; and
            len(name) &gt; 4)


def _is_sunder(name):
    &#34;&#34;&#34;Returns True if a _sunder_ name, False otherwise.&#34;&#34;&#34;
    return (name[0] == name[-1] == &#39;_&#39; and
            name[1:2] != &#39;_&#39; and
            name[-2:-1] != &#39;_&#39; and
            len(name) &gt; 2)


def _make_class_unpicklable(cls):
    &#34;&#34;&#34;Make the given class un-picklable.&#34;&#34;&#34;
    def _break_on_call_reduce(self, protocol=None):
        raise TypeError(&#39;%r cannot be pickled&#39; % self)
    cls.__reduce_ex__ = _break_on_call_reduce
    cls.__module__ = &#39;&lt;unknown&gt;&#39;


class _EnumDict(dict):
    &#34;&#34;&#34;Track enum member order and ensure member names are not reused.

    EnumMeta will use the names found in self._member_names as the
    enumeration member names.

    &#34;&#34;&#34;
    def __init__(self):
        super(_EnumDict, self).__init__()
        self._member_names = []

    def __setitem__(self, key, value):
        &#34;&#34;&#34;Changes anything not dundered or not a descriptor.

        If a descriptor is added with the same name as an enum member, the name
        is removed from _member_names (this may leave a hole in the numerical
        sequence of values).

        If an enum member name is used twice, an error is raised; duplicate
        values are not checked for.

        Single underscore (sunder) names are reserved.

        Note:   in 3.x __order__ is simply discarded as a not necessary piece
                leftover from 2.x

        &#34;&#34;&#34;
        if pyver &gt;= 3.0 and key in (&#39;_order_&#39;, &#39;__order__&#39;):
            return
        elif key == &#39;__order__&#39;:
            key = &#39;_order_&#39;
        if _is_sunder(key):
            if key != &#39;_order_&#39;:
                raise ValueError(&#39;_names_ are reserved for future Enum use&#39;)
        elif _is_dunder(key):
            pass
        elif key in self._member_names:
            # descriptor overwriting an enum?
            raise TypeError(&#39;Attempted to reuse key: %r&#39; % key)
        elif not _is_descriptor(value):
            if key in self:
                # enum overwriting a descriptor?
                raise TypeError(&#39;Key already defined as: %r&#39; % self[key])
            self._member_names.append(key)
        super(_EnumDict, self).__setitem__(key, value)


# Dummy value for Enum as EnumMeta explicity checks for it, but of course until
# EnumMeta finishes running the first time the Enum class doesn&#39;t exist.  This
# is also why there are checks in EnumMeta like `if Enum is not None`
Enum = None


class EnumMeta(type):
    &#34;&#34;&#34;Metaclass for Enum&#34;&#34;&#34;
    @classmethod
    def __prepare__(metacls, cls, bases):
        return _EnumDict()

    def __new__(metacls, cls, bases, classdict):
        # an Enum class is final once enumeration items have been defined; it
        # cannot be mixed with other types (int, float, etc.) if it has an
        # inherited __new__ unless a new __new__ is defined (or the resulting
        # class will fail).
        if type(classdict) is dict:
            original_dict = classdict
            classdict = _EnumDict()
            for k, v in original_dict.items():
                classdict[k] = v

        member_type, first_enum = metacls._get_mixins_(bases)
        __new__, save_new, use_args = metacls._find_new_(classdict, member_type,
                                                        first_enum)
        # save enum items into separate mapping so they don&#39;t get baked into
        # the new class
        members = dict((k, classdict[k]) for k in classdict._member_names)
        for name in classdict._member_names:
            del classdict[name]

        # py2 support for definition order
        _order_ = classdict.get(&#39;_order_&#39;)
        if _order_ is None:
            if pyver &lt; 3.0:
                try:
                    _order_ = [name for (name, value) in sorted(members.items(), key=lambda item: item[1])]
                except TypeError:
                    _order_ = [name for name in sorted(members.keys())]
            else:
                _order_ = classdict._member_names
        else:
            del classdict[&#39;_order_&#39;]
            if pyver &lt; 3.0:
                _order_ = _order_.replace(&#39;,&#39;, &#39; &#39;).split()
                aliases = [name for name in members if name not in _order_]
                _order_ += aliases

        # check for illegal enum names (any others?)
        invalid_names = set(members) &amp; set([&#39;mro&#39;])
        if invalid_names:
            raise ValueError(&#39;Invalid enum member name(s): %s&#39; % (
                &#39;, &#39;.join(invalid_names), ))

        # save attributes from super classes so we know if we can take
        # the shortcut of storing members in the class dict
        base_attributes = set([a for b in bases for a in b.__dict__])
        # create our new Enum type
        enum_class = super(EnumMeta, metacls).__new__(metacls, cls, bases, classdict)
        enum_class._member_names_ = []               # names in random order
        if OrderedDict is not None:
            enum_class._member_map_ = OrderedDict()
        else:
            enum_class._member_map_ = {}             # name-&gt;value map
        enum_class._member_type_ = member_type

        # Reverse value-&gt;name map for hashable values.
        enum_class._value2member_map_ = {}

        # instantiate them, checking for duplicates as we go
        # we instantiate first instead of checking for duplicates first in case
        # a custom __new__ is doing something funky with the values -- such as
        # auto-numbering ;)
        if __new__ is None:
            __new__ = enum_class.__new__
        for member_name in _order_:
            value = members[member_name]
            if not isinstance(value, tuple):
                args = (value, )
            else:
                args = value
            if member_type is tuple:   # special case for tuple enums
                args = (args, )     # wrap it one more time
            if not use_args or not args:
                enum_member = __new__(enum_class)
                if not hasattr(enum_member, &#39;_value_&#39;):
                    enum_member._value_ = value
            else:
                enum_member = __new__(enum_class, *args)
                if not hasattr(enum_member, &#39;_value_&#39;):
                    enum_member._value_ = member_type(*args)
            value = enum_member._value_
            enum_member._name_ = member_name
            enum_member.__objclass__ = enum_class
            enum_member.__init__(*args)
            # If another member with the same value was already defined, the
            # new member becomes an alias to the existing one.
            for name, canonical_member in enum_class._member_map_.items():
                if canonical_member.value == enum_member._value_:
                    enum_member = canonical_member
                    break
            else:
                # Aliases don&#39;t appear in member names (only in __members__).
                enum_class._member_names_.append(member_name)
            # performance boost for any member that would not shadow
            # a DynamicClassAttribute (aka _RouteClassAttributeToGetattr)
            if member_name not in base_attributes:
                setattr(enum_class, member_name, enum_member)
            # now add to _member_map_
            enum_class._member_map_[member_name] = enum_member
            try:
                # This may fail if value is not hashable. We can&#39;t add the value
                # to the map, and by-value lookups for this value will be
                # linear.
                enum_class._value2member_map_[value] = enum_member
            except TypeError:
                pass


        # If a custom type is mixed into the Enum, and it does not know how
        # to pickle itself, pickle.dumps will succeed but pickle.loads will
        # fail.  Rather than have the error show up later and possibly far
        # from the source, sabotage the pickle protocol for this class so
        # that pickle.dumps also fails.
        #
        # However, if the new class implements its own __reduce_ex__, do not
        # sabotage -- it&#39;s on them to make sure it works correctly.  We use
        # __reduce_ex__ instead of any of the others as it is preferred by
        # pickle over __reduce__, and it handles all pickle protocols.
        unpicklable = False
        if &#39;__reduce_ex__&#39; not in classdict:
            if member_type is not object:
                methods = (&#39;__getnewargs_ex__&#39;, &#39;__getnewargs__&#39;,
                        &#39;__reduce_ex__&#39;, &#39;__reduce__&#39;)
                if not any(m in member_type.__dict__ for m in methods):
                    _make_class_unpicklable(enum_class)
                    unpicklable = True


        # double check that repr and friends are not the mixin&#39;s or various
        # things break (such as pickle)
        for name in (&#39;__repr__&#39;, &#39;__str__&#39;, &#39;__format__&#39;, &#39;__reduce_ex__&#39;):
            class_method = getattr(enum_class, name)
            obj_method = getattr(member_type, name, None)
            enum_method = getattr(first_enum, name, None)
            if name not in classdict and class_method is not enum_method:
                if name == &#39;__reduce_ex__&#39; and unpicklable:
                    continue
                setattr(enum_class, name, enum_method)

        # method resolution and int&#39;s are not playing nice
        # Python&#39;s less than 2.6 use __cmp__

        if pyver &lt; 2.6:

            if issubclass(enum_class, int):
                setattr(enum_class, &#39;__cmp__&#39;, getattr(int, &#39;__cmp__&#39;))

        elif pyver &lt; 3.0:

            if issubclass(enum_class, int):
                for method in (
                        &#39;__le__&#39;,
                        &#39;__lt__&#39;,
                        &#39;__gt__&#39;,
                        &#39;__ge__&#39;,
                        &#39;__eq__&#39;,
                        &#39;__ne__&#39;,
                        &#39;__hash__&#39;,
                        ):
                    setattr(enum_class, method, getattr(int, method))

        # replace any other __new__ with our own (as long as Enum is not None,
        # anyway) -- again, this is to support pickle
        if Enum is not None:
            # if the user defined their own __new__, save it before it gets
            # clobbered in case they subclass later
            if save_new:
                setattr(enum_class, &#39;__member_new__&#39;, enum_class.__dict__[&#39;__new__&#39;])
            setattr(enum_class, &#39;__new__&#39;, Enum.__dict__[&#39;__new__&#39;])
        return enum_class

    def __bool__(cls):
        &#34;&#34;&#34;
        classes/types should always be True.
        &#34;&#34;&#34;
        return True

    def __call__(cls, value, names=None, module=None, type=None, start=1):
        &#34;&#34;&#34;Either returns an existing member, or creates a new enum class.

        This method is used both when an enum class is given a value to match
        to an enumeration member (i.e. Color(3)) and for the functional API
        (i.e. Color = Enum(&#39;Color&#39;, names=&#39;red green blue&#39;)).

        When used for the functional API: `module`, if set, will be stored in
        the new class&#39; __module__ attribute; `type`, if set, will be mixed in
        as the first base class.

        Note: if `module` is not set this routine will attempt to discover the
        calling module by walking the frame stack; if this is unsuccessful
        the resulting class will not be pickleable.

        &#34;&#34;&#34;
        if names is None:  # simple value lookup
            return cls.__new__(cls, value)
        # otherwise, functional API: we&#39;re creating a new Enum type
        return cls._create_(value, names, module=module, type=type, start=start)

    def __contains__(cls, member):
        return isinstance(member, cls) and member.name in cls._member_map_

    def __delattr__(cls, attr):
        # nicer error message when someone tries to delete an attribute
        # (see issue19025).
        if attr in cls._member_map_:
            raise AttributeError(
                    &#34;%s: cannot delete Enum member.&#34; % cls.__name__)
        super(EnumMeta, cls).__delattr__(attr)

    def __dir__(self):
        return ([&#39;__class__&#39;, &#39;__doc__&#39;, &#39;__members__&#39;, &#39;__module__&#39;] +
                self._member_names_)

    @property
    def __members__(cls):
        &#34;&#34;&#34;Returns a mapping of member name-&gt;value.

        This mapping lists all enum members, including aliases. Note that this
        is a copy of the internal mapping.

        &#34;&#34;&#34;
        return cls._member_map_.copy()

    def __getattr__(cls, name):
        &#34;&#34;&#34;Return the enum member matching `name`

        We use __getattr__ instead of descriptors or inserting into the enum
        class&#39; __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class&#39; __dict__) and
        enum members themselves.

        &#34;&#34;&#34;
        if _is_dunder(name):
            raise AttributeError(name)
        try:
            return cls._member_map_[name]
        except KeyError:
            raise AttributeError(name)

    def __getitem__(cls, name):
        return cls._member_map_[name]

    def __iter__(cls):
        return (cls._member_map_[name] for name in cls._member_names_)

    def __reversed__(cls):
        return (cls._member_map_[name] for name in reversed(cls._member_names_))

    def __len__(cls):
        return len(cls._member_names_)

    __nonzero__ = __bool__

    def __repr__(cls):
        return &#34;&lt;enum %r&gt;&#34; % cls.__name__

    def __setattr__(cls, name, value):
        &#34;&#34;&#34;Block attempts to reassign Enum members.

        A simple assignment to the class namespace only changes one of the
        several possible ways to get an Enum member from the Enum class,
        resulting in an inconsistent Enumeration.

        &#34;&#34;&#34;
        member_map = cls.__dict__.get(&#39;_member_map_&#39;, {})
        if name in member_map:
            raise AttributeError(&#39;Cannot reassign members.&#39;)
        super(EnumMeta, cls).__setattr__(name, value)

    def _create_(cls, class_name, names=None, module=None, type=None, start=1):
        &#34;&#34;&#34;Convenience method to create a new Enum class.

        `names` can be:

        * A string containing member names, separated either with spaces or
          commas.  Values are auto-numbered from 1.
        * An iterable of member names.  Values are auto-numbered from 1.
        * An iterable of (member name, value) pairs.
        * A mapping of member name -&gt; value.

        &#34;&#34;&#34;
        if pyver &lt; 3.0:
            # if class_name is unicode, attempt a conversion to ASCII
            if isinstance(class_name, unicode):
                try:
                    class_name = class_name.encode(&#39;ascii&#39;)
                except UnicodeEncodeError:
                    raise TypeError(&#39;%r is not representable in ASCII&#39; % class_name)
        metacls = cls.__class__
        if type is None:
            bases = (cls, )
        else:
            bases = (type, cls)
        classdict = metacls.__prepare__(class_name, bases)
        _order_ = []

        # special processing needed for names?
        if isinstance(names, basestring):
            names = names.replace(&#39;,&#39;, &#39; &#39;).split()
        if isinstance(names, (tuple, list)) and isinstance(names[0], basestring):
            names = [(e, i+start) for (i, e) in enumerate(names)]

        # Here, names is either an iterable of (name, value) or a mapping.
        item = None  # in case names is empty
        for item in names:
            if isinstance(item, basestring):
                member_name, member_value = item, names[item]
            else:
                member_name, member_value = item
            classdict[member_name] = member_value
            _order_.append(member_name)
        # only set _order_ in classdict if name/value was not from a mapping
        if not isinstance(item, basestring):
            classdict[&#39;_order_&#39;] = &#39; &#39;.join(_order_)
        enum_class = metacls.__new__(metacls, class_name, bases, classdict)

        # TODO: replace the frame hack if a blessed way to know the calling
        # module is ever developed
        if module is None:
            try:
                module = _sys._getframe(2).f_globals[&#39;__name__&#39;]
            except (AttributeError, ValueError):
                pass
        if module is None:
            _make_class_unpicklable(enum_class)
        else:
            enum_class.__module__ = module

        return enum_class

    @staticmethod
    def _get_mixins_(bases):
        &#34;&#34;&#34;Returns the type for creating enum members, and the first inherited
        enum class.

        bases: the tuple of bases that was given to __new__

        &#34;&#34;&#34;
        if not bases or Enum is None:
            return object, Enum


        # double check that we are not subclassing a class with existing
        # enumeration members; while we&#39;re at it, see if any other data
        # type has been mixed in so we can use the correct __new__
        member_type = first_enum = None
        for base in bases:
            if  (base is not Enum and
                    issubclass(base, Enum) and
                    base._member_names_):
                raise TypeError(&#34;Cannot extend enumerations&#34;)
        # base is now the last base in bases
        if not issubclass(base, Enum):
            raise TypeError(&#34;new enumerations must be created as &#34;
                    &#34;`ClassName([mixin_type,] enum_type)`&#34;)

        # get correct mix-in type (either mix-in type of Enum subclass, or
        # first base if last base is Enum)
        if not issubclass(bases[0], Enum):
            member_type = bases[0]     # first data type
            first_enum = bases[-1]  # enum type
        else:
            for base in bases[0].__mro__:
                # most common: (IntEnum, int, Enum, object)
                # possible:    (&lt;Enum &#39;AutoIntEnum&#39;&gt;, &lt;Enum &#39;IntEnum&#39;&gt;,
                #               &lt;class &#39;int&#39;&gt;, &lt;Enum &#39;Enum&#39;&gt;,
                #               &lt;class &#39;object&#39;&gt;)
                if issubclass(base, Enum):
                    if first_enum is None:
                        first_enum = base
                else:
                    if member_type is None:
                        member_type = base

        return member_type, first_enum

    if pyver &lt; 3.0:
        @staticmethod
        def _find_new_(classdict, member_type, first_enum):
            &#34;&#34;&#34;Returns the __new__ to be used for creating the enum members.

            classdict: the class dictionary given to __new__
            member_type: the data type whose __new__ will be used by default
            first_enum: enumeration to check for an overriding __new__

            &#34;&#34;&#34;
            # now find the correct __new__, checking to see of one was defined
            # by the user; also check earlier enum classes in case a __new__ was
            # saved as __member_new__
            __new__ = classdict.get(&#39;__new__&#39;, None)
            if __new__:
                return None, True, True      # __new__, save_new, use_args

            N__new__ = getattr(None, &#39;__new__&#39;)
            O__new__ = getattr(object, &#39;__new__&#39;)
            if Enum is None:
                E__new__ = N__new__
            else:
                E__new__ = Enum.__dict__[&#39;__new__&#39;]
            # check all possibles for __member_new__ before falling back to
            # __new__
            for method in (&#39;__member_new__&#39;, &#39;__new__&#39;):
                for possible in (member_type, first_enum):
                    try:
                        target = possible.__dict__[method]
                    except (AttributeError, KeyError):
                        target = getattr(possible, method, None)
                    if target not in [
                            None,
                            N__new__,
                            O__new__,
                            E__new__,
                            ]:
                        if method == &#39;__member_new__&#39;:
                            classdict[&#39;__new__&#39;] = target
                            return None, False, True
                        if isinstance(target, staticmethod):
                            target = target.__get__(member_type)
                        __new__ = target
                        break
                if __new__ is not None:
                    break
            else:
                __new__ = object.__new__

            # if a non-object.__new__ is used then whatever value/tuple was
            # assigned to the enum member name will be passed to __new__ and to the
            # new enum member&#39;s __init__
            if __new__ is object.__new__:
                use_args = False
            else:
                use_args = True

            return __new__, False, use_args
    else:
        @staticmethod
        def _find_new_(classdict, member_type, first_enum):
            &#34;&#34;&#34;Returns the __new__ to be used for creating the enum members.

            classdict: the class dictionary given to __new__
            member_type: the data type whose __new__ will be used by default
            first_enum: enumeration to check for an overriding __new__

            &#34;&#34;&#34;
            # now find the correct __new__, checking to see of one was defined
            # by the user; also check earlier enum classes in case a __new__ was
            # saved as __member_new__
            __new__ = classdict.get(&#39;__new__&#39;, None)

            # should __new__ be saved as __member_new__ later?
            save_new = __new__ is not None

            if __new__ is None:
                # check all possibles for __member_new__ before falling back to
                # __new__
                for method in (&#39;__member_new__&#39;, &#39;__new__&#39;):
                    for possible in (member_type, first_enum):
                        target = getattr(possible, method, None)
                        if target not in (
                                None,
                                None.__new__,
                                object.__new__,
                                Enum.__new__,
                                ):
                            __new__ = target
                            break
                    if __new__ is not None:
                        break
                else:
                    __new__ = object.__new__

            # if a non-object.__new__ is used then whatever value/tuple was
            # assigned to the enum member name will be passed to __new__ and to the
            # new enum member&#39;s __init__
            if __new__ is object.__new__:
                use_args = False
            else:
                use_args = True

            return __new__, save_new, use_args


########################################################
# In order to support Python 2 and 3 with a single
# codebase we have to create the Enum methods separately
# and then use the `type(name, bases, dict)` method to
# create the class.
########################################################
temp_enum_dict = {}
temp_enum_dict[&#39;__doc__&#39;] = &#34;Generic enumeration.\n\n    Derive from this class to define new enumerations.\n\n&#34;

def __new__(cls, value):
    # all enum instances are actually created during class construction
    # without calling this method; this method is called by the metaclass&#39;
    # __call__ (i.e. Color(3) ), and by pickle
    if type(value) is cls:
        # For lookups like Color(Color.red)
        value = value.value
        #return value
    # by-value search for a matching enum member
    # see if it&#39;s in the reverse mapping (for hashable values)
    try:
        if value in cls._value2member_map_:
            return cls._value2member_map_[value]
    except TypeError:
        # not there, now do long search -- O(n) behavior
        for member in cls._member_map_.values():
            if member.value == value:
                return member
    raise ValueError(&#34;%s is not a valid %s&#34; % (value, cls.__name__))
temp_enum_dict[&#39;__new__&#39;] = __new__
del __new__

def __repr__(self):
    return &#34;&lt;%s.%s: %r&gt;&#34; % (
            self.__class__.__name__, self._name_, self._value_)
temp_enum_dict[&#39;__repr__&#39;] = __repr__
del __repr__

def __str__(self):
    return &#34;%s.%s&#34; % (self.__class__.__name__, self._name_)
temp_enum_dict[&#39;__str__&#39;] = __str__
del __str__

if pyver &gt;= 3.0:
    def __dir__(self):
        added_behavior = [
                m
                for cls in self.__class__.mro()
                for m in cls.__dict__
                if m[0] != &#39;_&#39; and m not in self._member_map_
                ]
        return ([&#39;__class__&#39;, &#39;__doc__&#39;, &#39;__module__&#39;, ] + added_behavior)
    temp_enum_dict[&#39;__dir__&#39;] = __dir__
    del __dir__

def __format__(self, format_spec):
    # mixed-in Enums should use the mixed-in type&#39;s __format__, otherwise
    # we can get strange results with the Enum name showing up instead of
    # the value

    # pure Enum branch
    if self._member_type_ is object:
        cls = str
        val = str(self)
    # mix-in branch
    else:
        cls = self._member_type_
        val = self.value
    return cls.__format__(val, format_spec)
temp_enum_dict[&#39;__format__&#39;] = __format__
del __format__


####################################
# Python&#39;s less than 2.6 use __cmp__

if pyver &lt; 2.6:

    def __cmp__(self, other):
        if type(other) is self.__class__:
            if self is other:
                return 0
            return -1
        return NotImplemented
        raise TypeError(&#34;unorderable types: %s() and %s()&#34; % (self.__class__.__name__, other.__class__.__name__))
    temp_enum_dict[&#39;__cmp__&#39;] = __cmp__
    del __cmp__

else:

    def __le__(self, other):
        raise TypeError(&#34;unorderable types: %s() &lt;= %s()&#34; % (self.__class__.__name__, other.__class__.__name__))
    temp_enum_dict[&#39;__le__&#39;] = __le__
    del __le__

    def __lt__(self, other):
        raise TypeError(&#34;unorderable types: %s() &lt; %s()&#34; % (self.__class__.__name__, other.__class__.__name__))
    temp_enum_dict[&#39;__lt__&#39;] = __lt__
    del __lt__

    def __ge__(self, other):
        raise TypeError(&#34;unorderable types: %s() &gt;= %s()&#34; % (self.__class__.__name__, other.__class__.__name__))
    temp_enum_dict[&#39;__ge__&#39;] = __ge__
    del __ge__

    def __gt__(self, other):
        raise TypeError(&#34;unorderable types: %s() &gt; %s()&#34; % (self.__class__.__name__, other.__class__.__name__))
    temp_enum_dict[&#39;__gt__&#39;] = __gt__
    del __gt__


def __eq__(self, other):
    if type(other) is self.__class__:
        return self is other
    return NotImplemented
temp_enum_dict[&#39;__eq__&#39;] = __eq__
del __eq__

def __ne__(self, other):
    if type(other) is self.__class__:
        return self is not other
    return NotImplemented
temp_enum_dict[&#39;__ne__&#39;] = __ne__
del __ne__

def __hash__(self):
    return hash(self._name_)
temp_enum_dict[&#39;__hash__&#39;] = __hash__
del __hash__

def __reduce_ex__(self, proto):
    return self.__class__, (self._value_, )
temp_enum_dict[&#39;__reduce_ex__&#39;] = __reduce_ex__
del __reduce_ex__

# _RouteClassAttributeToGetattr is used to provide access to the `name`
# and `value` properties of enum members while keeping some measure of
# protection from modification, while still allowing for an enumeration
# to have members named `name` and `value`.  This works because enumeration
# members are not set directly on the enum class -- __getattr__ is
# used to look them up.

@_RouteClassAttributeToGetattr
def name(self):
    return self._name_
temp_enum_dict[&#39;name&#39;] = name
del name

@_RouteClassAttributeToGetattr
def value(self):
    return self._value_
temp_enum_dict[&#39;value&#39;] = value
del value

@classmethod
def _convert(cls, name, module, filter, source=None):
    &#34;&#34;&#34;
    Create a new Enum subclass that replaces a collection of global constants
    &#34;&#34;&#34;
    # convert all constants from source (or module) that pass filter() to
    # a new Enum called name, and export the enum and its members back to
    # module;
    # also, replace the __reduce_ex__ method so unpickling works in
    # previous Python versions
    module_globals = vars(_sys.modules[module])
    if source:
        source = vars(source)
    else:
        source = module_globals
    members = dict((name, value) for name, value in source.items() if filter(name))
    cls = cls(name, members, module=module)
    cls.__reduce_ex__ = _reduce_ex_by_name
    module_globals.update(cls.__members__)
    module_globals[name] = cls
    return cls
temp_enum_dict[&#39;_convert&#39;] = _convert
del _convert

Enum = EnumMeta(&#39;Enum&#39;, (object, ), temp_enum_dict)
del temp_enum_dict

# Enum has now been created
###########################

class IntEnum(int, Enum):
    &#34;&#34;&#34;Enum where members are also (and must be) ints&#34;&#34;&#34;

def _reduce_ex_by_name(self, proto):
    return self.name

def unique(enumeration):
    &#34;&#34;&#34;Class decorator that ensures only unique members exist in an enumeration.&#34;&#34;&#34;
    duplicates = []
    for name, member in enumeration.__members__.items():
        if name != member.name:
            duplicates.append((name, member.name))
    if duplicates:
        duplicate_names = &#39;, &#39;.join(
                [&#34;%s -&gt; %s&#34; % (alias, name) for (alias, name) in duplicates]
                )
        raise ValueError(&#39;duplicate names found in %r: %s&#39; %
                (enumeration, duplicate_names)
                )
    return enumeration</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="botball.core.helpers.enum.unique"><code class="name flex">
<span>def <span class="ident">unique</span></span>(<span>enumeration)</span>
</code></dt>
<dd>
<section class="desc"><p>Class decorator that ensures only unique members exist in an enumeration.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def unique(enumeration):
    &#34;&#34;&#34;Class decorator that ensures only unique members exist in an enumeration.&#34;&#34;&#34;
    duplicates = []
    for name, member in enumeration.__members__.items():
        if name != member.name:
            duplicates.append((name, member.name))
    if duplicates:
        duplicate_names = &#39;, &#39;.join(
                [&#34;%s -&gt; %s&#34; % (alias, name) for (alias, name) in duplicates]
                )
        raise ValueError(&#39;duplicate names found in %r: %s&#39; %
                (enumeration, duplicate_names)
                )
    return enumeration</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="botball.core.helpers.enum.Enum"><code class="flex name class">
<span>class <span class="ident">Enum</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Generic enumeration.</p>
<p>Derive from this class to define new enumerations.</p></section>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="botball.core.helpers.enum.IntEnum" href="#botball.core.helpers.enum.IntEnum">IntEnum</a></li>
<li><a title="botball.core.components.devices.camera.CameraTrackingColor.CameraTrackingColor" href="../components/devices/camera/CameraTrackingColor.html#botball.core.components.devices.camera.CameraTrackingColor.CameraTrackingColor">CameraTrackingColor</a></li>
<li><a title="botball.core.components.Direction.Direction" href="../components/Direction.html#botball.core.components.Direction.Direction">Direction</a></li>
</ul>
</dd>
<dt id="botball.core.helpers.enum.IntEnum"><code class="flex name class">
<span>class <span class="ident">IntEnum</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum where members are also (and must be) ints</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class IntEnum(int, Enum):
    &#34;&#34;&#34;Enum where members are also (and must be) ints&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.int</li>
<li><a title="botball.core.helpers.enum.Enum" href="#botball.core.helpers.enum.Enum">Enum</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="botball.core.helpers" href="index.html">botball.core.helpers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="botball.core.helpers.enum.unique" href="#botball.core.helpers.enum.unique">unique</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="botball.core.helpers.enum.Enum" href="#botball.core.helpers.enum.Enum">Enum</a></code></h4>
</li>
<li>
<h4><code><a title="botball.core.helpers.enum.IntEnum" href="#botball.core.helpers.enum.IntEnum">IntEnum</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>